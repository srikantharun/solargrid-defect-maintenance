apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-server
  namespace: solar-panel-detection
spec:
  replicas: 2
  selector:
    matchLabels:
      app: api-server
  template:
    metadata:
      labels:
        app: api-server
    spec:
      containers:
      - name: api-server
        image: python:3.9-slim
        command: ["/bin/bash", "-c"]
        args:
        - |
          pip install flask requests redis flask-cors flask-swagger-ui && 
          mkdir -p /app && 
          cat > /app/server.py << 'EOF'
          import os
          import json
          import logging
          from datetime import datetime
          from flask import Flask, request, jsonify
          import requests
          import redis
          from flask_cors import CORS

          # Configure logging
          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
          )
          logger = logging.getLogger('api-server')

          # Configuration from environment variables
          REDIS_HOST = os.environ.get('REDIS_HOST', 'redis')
          REDIS_PORT = int(os.environ.get('REDIS_PORT', '6379'))
          AI_PROCESSOR_URL = os.environ.get('AI_PROCESSOR_URL', 'http://ai-processor-service:8081')
          DATA_COLLECTOR_URL = os.environ.get('DATA_COLLECTOR_URL', 'http://data-collector-service:8080')
          API_PORT = int(os.environ.get('API_PORT', '8000'))
          ENABLE_SWAGGER = os.environ.get('ENABLE_SWAGGER', 'true').lower() == 'true'

          # Flask application
          app = Flask(__name__)
          CORS(app)  # Enable CORS for all routes

          # Global variables
          redis_client = None

          # Initialize connections
          def init_redis():
              global redis_client
              
              # Connect to Redis
              try:
                  redis_client = redis.Redis(host=REDIS_HOST, port=REDIS_PORT)
                  redis_client.ping()  # Test the connection
                  logger.info(f"Connected to Redis at {REDIS_HOST}:{REDIS_PORT}")
                  return True
              except Exception as e:
                  logger.error(f"Failed to connect to Redis: {e}")
                  redis_client = None
                  return False

          # API routes

          @app.route('/api/health', methods=['GET'])
          def health_check():
              """API health check endpoint."""
              health = {
                  "status": "ok",
                  "timestamp": datetime.now().isoformat(),
                  "redis_connected": redis_client is not None,
                  "services": {
                      "ai_processor": "unknown",
                      "data_collector": "unknown"
                  }
              }
              
              # Check AI processor connection
              try:
                  response = requests.get(f"{AI_PROCESSOR_URL}/panels/status", timeout=2)
                  health["services"]["ai_processor"] = "up" if response.status_code == 200 else "down"
              except:
                  health["services"]["ai_processor"] = "down"
              
              # Check data collector connection
              try:
                  response = requests.get(f"{DATA_COLLECTOR_URL}/latest/temperature", timeout=2)
                  health["services"]["data_collector"] = "up" if response.status_code == 200 else "down"
              except:
                  health["services"]["data_collector"] = "down"
              
              # Determine overall health
              if (not redis_client or 
                  health["services"]["ai_processor"] == "down" or 
                  health["services"]["data_collector"] == "down"):
                  health["status"] = "degraded"
              
              return jsonify(health)

          @app.route('/api/panel/<panel_id>/defects', methods=['GET'])
          def get_panel_defects(panel_id):
              """Get defects for a specific panel."""
              try:
                  response = requests.get(f"{AI_PROCESSOR_URL}/panel/{panel_id}/defects")
                  return jsonify(response.json()), response.status_code
              except Exception as e:
                  logger.error(f"Error retrieving panel defects: {e}")
                  return jsonify({"error": str(e)}), 500

          @app.route('/api/panel/<panel_id>/analyze', methods=['POST'])
          def analyze_panel(panel_id):
              """Trigger analysis for a specific panel."""
              try:
                  location_code = request.args.get('location_code', 'unknown')
                  response = requests.post(
                      f"{AI_PROCESSOR_URL}/panel/{panel_id}/analysis",
                      params={"location_code": location_code}
                  )
                  return jsonify(response.json()), response.status_code
              except Exception as e:
                  logger.error(f"Error triggering panel analysis: {e}")
                  return jsonify({"error": str(e)}), 500

          @app.route('/api/panel/<panel_id>/data', methods=['GET'])
          def get_panel_data(panel_id):
              """Get latest sensor data for a specific panel."""
              try:
                  response = requests.get(f"{DATA_COLLECTOR_URL}/panel/{panel_id}")
                  return jsonify(response.json()), response.status_code
              except Exception as e:
                  logger.error(f"Error retrieving panel data: {e}")
                  return jsonify({"error": str(e)}), 500

          @app.route('/api/location/<location_code>/data', methods=['GET'])
          def get_location_data(location_code):
              """Get latest sensor data for a specific location."""
              try:
                  response = requests.get(f"{DATA_COLLECTOR_URL}/latest/location/{location_code}")
                  return jsonify(response.json()), response.status_code
              except Exception as e:
                  logger.error(f"Error retrieving location data: {e}")
                  return jsonify({"error": str(e)}), 500

          @app.route('/api/defects/recent', methods=['GET'])
          def get_recent_defects():
              """Get recent defects from all panels."""
              try:
                  response = requests.get(f"{DATA_COLLECTOR_URL}/defects/recent")
                  return jsonify(response.json()), response.status_code
              except Exception as e:
                  logger.error(f"Error retrieving recent defects: {e}")
                  return jsonify({"error": str(e)}), 500

          @app.route('/api/defects/summary', methods=['GET'])
          def get_defects_summary():
              """Get a summary of all defects."""
              try:
                  response = requests.get(f"{AI_PROCESSOR_URL}/defects/summary")
                  return jsonify(response.json()), response.status_code
              except Exception as e:
                  logger.error(f"Error retrieving defects summary: {e}")
                  return jsonify({"error": str(e)}), 500

          @app.route('/api/panels/status', methods=['GET'])
          def get_panels_status():
              """Get status of all panels."""
              try:
                  response = requests.get(f"{AI_PROCESSOR_URL}/panels/status")
                  return jsonify(response.json()), response.status_code
              except Exception as e:
                  logger.error(f"Error retrieving panels status: {e}")
                  return jsonify({"error": str(e)}), 500

          @app.route('/api/documentation', methods=['GET'])
          def get_api_docs():
              """Get API documentation."""
              docs = {
                  "api_version": "1.0",
                  "title": "Solar Panel Defect Detection API",
                  "description": "API for detecting defects in solar panels using sensor data",
                  "base_url": "/api",
                  "endpoints": [
                      {
                          "path": "/health",
                          "method": "GET",
                          "description": "Check API health"
                      },
                      {
                          "path": "/panel/{panel_id}/defects",
                          "method": "GET",
                          "description": "Get defects for a specific panel",
                          "parameters": [
                              {
                                  "name": "panel_id",
                                  "in": "path",
                                  "required": true,
                                  "description": "ID of the panel to retrieve defects for"
                              }
                          ]
                      },
                      {
                          "path": "/panel/{panel_id}/analyze",
                          "method": "POST",
                          "description": "Trigger analysis for a specific panel",
                          "parameters": [
                              {
                                  "name": "panel_id",
                                  "in": "path",
                                  "required": true,
                                  "description": "ID of the panel to analyze"
                              },
                              {
                                  "name": "location_code",
                                  "in": "query",
                                  "required": false,
                                  "description": "Location code of the panel"
                              }
                          ]
                      },
                      {
                          "path": "/panel/{panel_id}/data",
                          "method": "GET",
                          "description": "Get latest sensor data for a specific panel",
                          "parameters": [
                              {
                                  "name": "panel_id",
                                  "in": "path",
                                  "required": true,
                                  "description": "ID of the panel to retrieve data for"
                              }
                          ]
                      },
                      {
                          "path": "/location/{location_code}/data",
                          "method": "GET",
                          "description": "Get latest sensor data for a specific location",
                          "parameters": [
                              {
                                  "name": "location_code",
                                  "in": "path",
                                  "required": true,
                                  "description": "Location code to retrieve data for"
                              }
                          ]
                      },
                      {
                          "path": "/defects/recent",
                          "method": "GET",
                          "description": "Get recent defects from all panels"
                      },
                      {
                          "path": "/defects/summary",
                          "method": "GET",
                          "description": "Get a summary of all defects"
                      },
                      {
                          "path": "/panels/status",
                          "method": "GET",
                          "description": "Get status of all panels"
                      },
                      {
                          "path": "/documentation",
                          "method": "GET",
                          "description": "Get API documentation"
                      }
                  ]
              }
              return jsonify(docs)

          @app.route('/', methods=['GET'])
          def root():
              """Root endpoint - redirects to API documentation."""
              return jsonify({
                  "name": "Solar Panel Defect Detection API",
                  "version": "1.0",
                  "documentation": "/api/documentation"
              })

          # If Swagger UI is enabled, set it up
          if ENABLE_SWAGGER:
              try:
                  from flask_swagger_ui import get_swaggerui_blueprint
                  
                  SWAGGER_URL = '/swagger'
                  API_URL = '/api/documentation'
                  
                  swaggerui_blueprint = get_swaggerui_blueprint(
                      SWAGGER_URL,
                      API_URL,
                      config={
                          'app_name': "Solar Panel Defect Detection API"
                      }
                  )
                  app.register_blueprint(swaggerui_blueprint, url_prefix=SWAGGER_URL)
                  logger.info("Swagger UI enabled at /swagger")
              except ImportError:
                  logger.warning("flask_swagger_ui not installed, Swagger UI disabled")
                  ENABLE_SWAGGER = False

          def main():
              """Main function to start the API server."""
              logger.info("Starting API Server")
              
              # Initialize Redis connection
              init_redis()
              
              # Start the API server
              logger.info(f"Starting API server on port {API_PORT}")
              app.run(host='0.0.0.0', port=API_PORT)

          if __name__ == "__main__":
              main()
          EOF
          python /app/server.py
        env:
        - name: REDIS_HOST
          value: "redis"
        - name: REDIS_PORT
          value: "6379"
        - name: AI_PROCESSOR_URL
          value: "http://ai-processor-service:8081"
        - name: DATA_COLLECTOR_URL
          value: "http://data-collector-service:8080"
        - name: ENABLE_SWAGGER
          value: "true"
        - name: API_PORT
          value: "8000"
        ports:
        - containerPort: 8000
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "300m"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ai-processor
  namespace: solar-panel-detection
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ai-processor
  template:
    metadata:
      labels:
        app: ai-processor
    spec:
      containers:
      - name: ai-processor
        image: tensorflow/tensorflow:2.8.0
        command: ["/bin/bash", "-c"]
        args:
        - |
          pip install flask requests redis pymongo numpy pandas scikit-learn joblib kafka-python prometheus_client && 
          mkdir -p /app /models && 
          cat > /app/processor.py << 'EOF'
          import os
          import json
          import time
          import logging
          import threading
          import numpy as np
          import pandas as pd
          from datetime import datetime, timedelta
          import base64
          from sklearn.ensemble import IsolationForest
          from flask import Flask, request, jsonify
          import requests
          import joblib
          import redis
          from tensorflow.keras.models import load_model
          import prometheus_client
          from prometheus_client import Counter, Gauge, Histogram, Summary

          # Configure logging
          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
          )
          logger = logging.getLogger('ai-processor')

          # Configuration from environment variables
          REDIS_HOST = os.environ.get('REDIS_HOST', 'redis')
          REDIS_PORT = int(os.environ.get('REDIS_PORT', '6379'))
          DATA_COLLECTOR_URL = os.environ.get('DATA_COLLECTOR_URL', 'http://data-collector-service:8080')
          MODEL_DIR = os.environ.get('MODEL_DIR', '/models')
          API_PORT = int(os.environ.get('API_PORT', '8081'))
          PROCESSING_INTERVAL = int(os.environ.get('PROCESSING_INTERVAL', '300'))  # 5 minutes
          METRICS_PORT = int(os.environ.get('METRICS_PORT', '9102'))

          # Flask application
          app = Flask(__name__)

          # Global variables
          redis_client = None
          anomaly_detector = None
          thermal_model = None
          panel_status_cache = {}

          # Prometheus metrics
          defects_detected = Counter('solar_panel_defects', 'Number of defects detected', ['defect_type', 'severity'])
          panel_temperature = Gauge('solar_panel_temperature', 'Current panel temperature')
          panel_irradiance = Gauge('solar_panel_irradiance', 'Current panel irradiance')
          panel_efficiency = Gauge('solar_panel_efficiency', 'Current panel efficiency')
          analysis_duration = Histogram('solar_panel_analysis_duration', 'Time spent on analysis')

          # Initialize connections and models
          def init():
              global redis_client, anomaly_detector, thermal_model
              
              # Connect to Redis
              try:
                  redis_client = redis.Redis(host=REDIS_HOST, port=REDIS_PORT)
                  redis_client.ping()  # Test the connection
                  logger.info(f"Connected to Redis at {REDIS_HOST}:{REDIS_PORT}")
              except Exception as e:
                  logger.error(f"Failed to connect to Redis: {e}")
                  redis_client = None
              
              # Load or create anomaly detection model
              try:
                  model_path = os.path.join(MODEL_DIR, 'anomaly_detector.joblib')
                  if os.path.exists(model_path):
                      anomaly_detector = joblib.load(model_path)
                      logger.info("Loaded anomaly detection model")
                  else:
                      logger.info("Creating new anomaly detection model")
                      anomaly_detector = IsolationForest(
                          n_estimators=100,
                          contamination=0.05,
                          random_state=42
                      )
                      # Save the model for future use
                      os.makedirs(MODEL_DIR, exist_ok=True)
                      joblib.dump(anomaly_detector, model_path)
                      logger.info(f"Created and saved anomaly detection model to {model_path}")
              except Exception as e:
                  logger.error(f"Error with anomaly detection model: {e}")
                  anomaly_detector = None
              
              # Load thermal imaging model if it exists
              try:
                  thermal_model_path = os.path.join(MODEL_DIR, 'thermal_model.h5')
                  if os.path.exists(thermal_model_path):
                      thermal_model = load_model(thermal_model_path)
                      logger.info("Loaded thermal imaging model")
                  else:
                      logger.warning("Thermal imaging model not found, will use rule-based analysis")
              except Exception as e:
                  logger.error(f"Error loading thermal imaging model: {e}")
                  thermal_model = None
              
              # Start Prometheus metrics server
              start_metrics_server()

          # Rule-based defect detection functions
          def analyze_temperature_data(data, location_code, panel_id):
              """Analyze temperature data for anomalies."""
              if not data or 'value' not in data:
                  return None
              
              temperature = data['value']
              is_defect = False
              defect_type = None
              severity = "low"
              
              # Basic rules based on absolute temperature values
              if temperature > 85:
                  is_defect = True
                  defect_type = "overheating"
                  severity = "high"
              elif temperature > 75:
                  is_defect = True
                  defect_type = "high_temperature"
                  severity = "medium"
              
              # Check temperature relative to ambient if available
              if 'metadata' in data and 'ambient_temperature' in data['metadata']:
                  ambient = data['metadata']['ambient_temperature']
                  temp_diff = temperature - ambient
                  
                  if temp_diff > 35:
                      is_defect = True
                      defect_type = "hotspot"
                      severity = "high"
                  elif temp_diff > 25:
                      is_defect = True
                      defect_type = "thermal_anomaly"
                      severity = "medium"
              
              # Update Prometheus metrics
              panel_temperature.set(temperature)
              
              if is_defect:
                  defects_detected.labels(defect_type=defect_type, severity=severity).inc()
                  return {
                      "location_code": location_code,
                      "panel_id": panel_id,
                      "identified_defect": defect_type,
                      "severity": severity,
                      "temperature": temperature,
                      "confidence": 0.75 if severity == "high" else 0.6,
                      "possible_solution": get_solution_for_defect(defect_type, severity)
                  }
              
              return None

          def analyze_irradiance_data(data, temp_data, location_code, panel_id):
              """Analyze irradiance data alongside temperature."""
              if not data or 'value' not in data:
                  return None
              
              irradiance = data['value']
              is_defect = False
              defect_type = None
              severity = "low"
              
              # Update Prometheus metrics
              panel_irradiance.set(irradiance)
              
              # Calculate efficiency (simplified)
              if temp_data and 'value' in temp_data:
                  temperature = temp_data['value']
                  # Simple efficiency model: decreases with temperature
                  efficiency = max(0, min(100, 100 - (temperature - 25) * 0.5))
                  panel_efficiency.set(efficiency)
              
              # Check for low irradiance vs high temperature
              if temp_data and 'value' in temp_data:
                  temperature = temp_data['value']
                  # If high temperature but low irradiance, something might be wrong
                  if temperature > 65 and irradiance < 400:
                      is_defect = True
                      defect_type = "temp_irradiance_mismatch"
                      severity = "medium"
              
              # Check for dust accumulation - sustained low irradiance when clear sky
              if (irradiance < 300 and 'metadata' in data and 
                      data['metadata'].get('sky_condition') == 'clear'):
                  is_defect = True
                  defect_type = "potential_dust_accumulation"
                  severity = "medium"
              
              # Check for fault detected by the sensor itself
              if 'metadata' in data and data['metadata'].get('fault_detected'):
                  is_defect = True
                  defect_type = data['metadata'].get('fault_type', 'unknown_fault')
                  severity = "medium"
              
              if is_defect:
                  defects_detected.labels(defect_type=defect_type, severity=severity).inc()
                  return {
                      "location_code": location_code,
                      "panel_id": panel_id,
                      "identified_defect": defect_type,
                      "severity": severity,
                      "irradiance": irradiance,
                      "confidence": 0.7,
                      "possible_solution": get_solution_for_defect(defect_type, severity)
                  }
              
              return None

          def analyze_humidity_data(data, location_code, panel_id):
              """Analyze humidity data for moisture-related defects."""
              if not data or 'value' not in data:
                  return None
              
              humidity = data['value']
              is_defect = False
              defect_type = None
              severity = "low"
              
              # Very high sustained humidity can lead to moisture ingress
              if humidity > 90:
                  is_defect = True
                  defect_type = "high_humidity_exposure"
                  severity = "medium"
              
              # Check for fault detected by the sensor itself
              if 'metadata' in data and data['metadata'].get('fault_detected'):
                  is_defect = True
                  defect_type = data['metadata'].get('fault_type', 'unknown_fault')
                  severity = "medium"
              
              if is_defect:
                  defects_detected.labels(defect_type=defect_type, severity=severity).inc()
                  return {
                      "location_code": location_code,
                      "panel_id": panel_id,
                      "identified_defect": defect_type,
                      "severity": severity,
                      "humidity": humidity,
                      "confidence": 0.65,
                      "possible_solution": get_solution_for_defect(defect_type, severity)
                  }
              
              return None

          def analyze_wind_data(data, location_code, panel_id):
              """Analyze wind data for potential mechanical issues."""
              if not data or 'value' not in data:
                  return None
              
              wind_speed = data['value']
              is_defect = False
              defect_type = None
              severity = "low"
              
              # High wind speed can indicate mounting/structural issues
              if wind_speed > 15 and 'metadata' in data and data['metadata'].get('wind_stress') == 'high':
                  is_defect = True
                  defect_type = "high_wind_stress"
                  severity = "medium"
              
              # Check for fault detected by the sensor itself
              if 'metadata' in data and data['metadata'].get('fault_detected'):
                  is_defect = True
                  defect_type = data['metadata'].get('fault_type', 'unknown_fault')
                  severity = "high" if defect_type == "mounting_issue" else "medium"
              
              if is_defect:
                  defects_detected.labels(defect_type=defect_type, severity=severity).inc()
                  return {
                      "location_code": location_code,
                      "panel_id": panel_id,
                      "identified_defect": defect_type,
                      "severity": severity,
                      "wind_speed": wind_speed,
                      "confidence": 0.75 if severity == "high" else 0.6,
                      "possible_solution": get_solution_for_defect(defect_type, severity)
                  }
              
              return None

          def analyze_thermal_image(data, location_code, panel_id):
              """Analyze thermal imaging data for defects."""
              if not data or 'thermal_data' not in data:
                  return None
              
              thermal_data = data['thermal_data']
              has_defect = data.get('defect_detected', False)
              defect_info = data.get('defect_info')
              
              # If the thermal imaging sensor has already detected a defect, use that
              if has_defect and defect_info:
                  defect_type = defect_info.get('type', 'unknown_defect')
                  severity = defect_info.get('severity', 'medium')
                  
                  defects_detected.labels(defect_type=defect_type, severity=severity).inc()
                  
                  return {
                      "location_code": location_code,
                      "panel_id": panel_id,
                      "identified_defect": defect_type,
                      "severity": severity,
                      "temperature_difference": thermal_data.get('temperature_difference'),
                      "max_temperature": thermal_data.get('max_temperature'),
                      "confidence": 0.85,  # Higher confidence for thermal image detection
                      "defect_location": defect_info.get('location'),
                      "possible_solution": get_solution_for_defect(defect_type, severity)
                  }
              
              # Otherwise, do our own analysis based on the thermal statistics
              if 'temperature_difference' in thermal_data and thermal_data['temperature_difference'] > 20:
                  defect_type = "potential_hotspot"
                  severity = "medium"
                  
                  defects_detected.labels(defect_type=defect_type, severity=severity).inc()
                  
                  return {
                      "location_code": location_code,
                      "panel_id": panel_id,
                      "identified_defect": defect_type,
                      "severity": severity,
                      "temperature_difference": thermal_data.get('temperature_difference'),
                      "max_temperature": thermal_data.get('max_temperature'),
                      "confidence": 0.7,
                      "possible_solution": get_solution_for_defect(defect_type, severity)
                  }
              
              return None

          def get_solution_for_defect(defect_type, severity):
              """Get recommended solution for a specific defect type."""
              solutions = {
                  "overheating": {
                      "high": "Immediate inspection required. Disconnect the panel from the system.",
                      "medium": "Schedule inspection within 48 hours. Check for ventilation issues."
                  },
                  "high_temperature": {
                      "high": "Immediate cooling required. Inspect for hotspots.",
                      "medium": "Monitor closely and schedule inspection within 72 hours."
                  },
                  "hotspot": {
                      "high": "Immediate inspection required. May need panel replacement.",
                      "medium": "Schedule thermal imaging within 48 hours. Check for shading issues."
                  },
                  "thermal_anomaly": {
                      "high": "Immediate inspection with thermal camera.",
                      "medium": "Schedule inspection within 72 hours."
                  },
                  "temp_irradiance_mismatch": {
                      "high": "Inspect for internal electrical issues.",
                      "medium": "Schedule maintenance to check connections and bypass diodes."
                  },
                  "potential_dust_accumulation": {
                      "high": "Immediate cleaning required.",
                      "medium": "Schedule cleaning within the week."
                  },
                  "cell_crack": {
                      "high": "Panel replacement recommended.",
                      "medium": "Monitor performance, may need replacement if efficiency drops further."
                  },
                  "bypass_diode_failure": {
                      "high": "Replace bypass diode immediately to prevent panel damage.",
                      "medium": "Schedule replacement of bypass diode within the week."
                  },
                  "delamination": {
                      "high": "Panel replacement required.",
                      "medium": "Monitor closely, plan for replacement if spreading."
                  },
                  "potential_induced_degradation": {
                      "high": "Check system grounding and voltage configuration.",
                      "medium": "Schedule electrical testing for the array."
                  },
                  "high_humidity_exposure": {
                      "high": "Check for moisture ingress, seal or replace if necessary.",
                      "medium": "Monitor for moisture accumulation during humid conditions."
                  },
                  "high_wind_stress": {
                      "high": "Immediate inspection of mounting system required.",
                      "medium": "Schedule structural inspection within the week."
                  },
                  "potential_hotspot": {
                      "high": "Immediate thermal inspection required.",
                      "medium": "Schedule detailed thermal scan within 72 hours."
                  }
              }
              
              if defect_type in solutions and severity in solutions[defect_type]:
                  return solutions[defect_type][severity]
              
              # Default solution if specific one not found
              if severity == "high":
                  return "Immediate inspection required."
              elif severity == "medium":
                  return "Schedule inspection within 72 hours."
              else:
                  return "Monitor during next regular maintenance."

          def process_panel_data(panel_id, location_code):
              """Process all available data for a specific panel."""
              try:
                  # Get all sensor data for this panel
                  response = requests.get(f"{DATA_COLLECTOR_URL}/panel/{panel_id}")
                  if response.status_code != 200:
                      logger.error(f"Failed to get data for panel {panel_id}: HTTP {response.status_code}")
                      return None
                  
                  panel_data = response.json()
                  
                  # Extract data by sensor type
                  temp_data = None
                  irr_data = None
                  hum_data = None
                  wind_data = None
                  thermal_data = None
                  
                  for item in panel_data:
                      if item['sensor_type'] == 'temperature':
                          temp_data = item
                      elif item['sensor_type'] == 'irradiance':
                          irr_data = item
                      elif item['sensor_type'] == 'humidity':
                          hum_data = item
                      elif item['sensor_type'] == 'wind_speed':
                          wind_data = item
                      elif item['sensor_type'] == 'thermal_imaging':
                          thermal_data = item
                  
                  # Analyze each sensor type
                  defects = []
                  
                  temp_defect = analyze_temperature_data(temp_data, location_code, panel_id)
                  if temp_defect:
                      defects.append(temp_defect)
                  
                  irr_defect = analyze_irradiance_data(irr_data, temp_data, location_code, panel_id)
                  if irr_defect:
                      defects.append(irr_defect)
                  
                  hum_defect = analyze_humidity_data(hum_data, location_code, panel_id)
                  if hum_defect:
                      defects.append(hum_defect)
                  
                  wind_defect = analyze_wind_data(wind_data, location_code, panel_id)
                  if wind_defect:
                      defects.append(wind_defect)
                  
                  thermal_defect = analyze_thermal_image(thermal_data, location_code, panel_id)
                  if thermal_defect:
                      defects.append(thermal_defect)
                  
                  # Integration with anomaly detector (machine learning)
                  if anomaly_detector and temp_data and irr_data:
                      try:
                          # Extract features for anomaly detection
                          features = np.array([[
                              temp_data['value'],
                              irr_data['value'],
                              temp_data['value'] / (irr_data['value'] + 1e-5)  # Temperature/irradiance ratio
                          ]])
                          
                          # Predict anomaly (-1 for anomalies, 1 for normal)
                          prediction = anomaly_detector.predict(features)
                          
                          if prediction[0] == -1:
                              # This is an anomaly according to the model
                              anomaly_score = anomaly_detector.score_samples(features)[0]
                              
                              # Only report if confidence is high enough (lower scores = more anomalous)
                              if anomaly_score < -0.5:
                                  anomaly_defect = {
                                      "location_code": location_code,
                                      "panel_id": panel_id,
                                      "identified_defect": "anomalous_behavior",
                                      "severity": "medium",
                                      "anomaly_score": float(anomaly_score),
                                      "confidence": min(0.9, 0.6 - anomaly_score/2),  # Convert score to confidence
                                      "possible_solution": "Detailed inspection recommended due to unusual sensor readings."
                                  }
                                  defects.append(anomaly_defect)
                                  defects_detected.labels(defect_type="anomalous_behavior", severity="medium").inc()
                      except Exception as e:
                          logger.error(f"Error in anomaly detection: {e}")
                  
                  # Update panel status cache
                  panel_status_cache[panel_id] = {
                      "last_analyzed": datetime.now().isoformat(),
                      "location_code": location_code,
                      "temperature": temp_data['value'] if temp_data else None,
                      "irradiance": irr_data['value'] if irr_data else None,
                      "defects_found": len(defects),
                      "status": "alert" if defects else "normal"
                  }
                  
                  # If using Redis, store the results
                  if redis_client:
                      redis_client.set(
                          f"panel:{panel_id}:analysis", 
                          json.dumps({
                              "timestamp": datetime.now().isoformat(),
                              "defects": defects,
                              "status": "alert" if defects else "normal"
                          }),
                          ex=86400  # Expire after 24 hours
                      )
                  
                  return {
                      "panel_id": panel_id,
                      "location_code": location_code,
                      "analyzed_at": datetime.now().isoformat(),
                      "defects": defects,
                      "status": "alert" if defects else "normal"
                  }
              
              except Exception as e:
                  logger.error(f"Error processing panel data: {e}")
                  return {
                      "panel_id": panel_id,
                      "error": str(e),
                      "status": "error"
                  }

          def background_processing():
              """Background thread to periodically analyze all panels."""
              while True:
                  try:
                      logger.info("Starting background analysis of all panels")
                      
                      # Get a list of all panels from the data collector
                      # This is simplified - in a real system, we would need to query for all active panels
                      # For now, we'll process any panels that have recent data
                      all_panels = {}
                      
                      try:
                          # Attempt to get recent defects which might contain panel IDs
                          response = requests.get(f"{DATA_COLLECTOR_URL}/defects/recent")
                          if response.status_code == 200:
                              defects = response.json()
                              for defect in defects:
                                  if 'panel_id' in defect and 'location_code' in defect:
                                      all_panels[defect['panel_id']] = defect['location_code']
                      except Exception as e:
                          logger.error(f"Error getting recent defects: {e}")
                      
                      # Process each panel
                      for panel_id, location_code in all_panels.items():
                          try:
                              result = process_panel_data(panel_id, location_code)
                              if result:
                                  logger.info(f"Analyzed panel {panel_id}: found {len(result.get('defects', []))} defects")
                          except Exception as e:
                              logger.error(f"Error analyzing panel {panel_id}: {e}")
                      
                      logger.info(f"Background analysis complete. Processed {len(all_panels)} panels")
                  except Exception as e:
                      logger.error(f"Error in background processing: {e}")
                  
                  # Sleep until next processing cycle
                  time.sleep(PROCESSING_INTERVAL)

          def start_metrics_server():
              """Start the Prometheus metrics server."""
              try:
                  prometheus_client.start_http_server(METRICS_PORT)
                  logger.info(f"Started Prometheus metrics server on port {METRICS_PORT}")
              except Exception as e:
                  logger.error(f"Failed to start Prometheus metrics server: {e}")

          # API routes
          @app.route('/panel/<panel_id>/defects', methods=['GET'])
          def get_panel_defects(panel_id):
              """Get defects for a specific panel."""
              if redis_client:
                  cached_analysis = redis_client.get(f"panel:{panel_id}:analysis")
                  if cached_analysis:
                      analysis = json.loads(cached_analysis)
                      return jsonify(analysis.get('defects', []))
              
              # No cached data available
              return jsonify([])

          @app.route('/panel/<panel_id>/analysis', methods=['POST'])
          def analyze_panel(panel_id):
              """Trigger analysis for a specific panel."""
              location_code = request.args.get('location_code', 'unknown')
              
              result = process_panel_data(panel_id, location_code)
              if result:
                  return jsonify(result)
              else:
                  return jsonify({"error": "Failed to analyze panel"}), 500

          @app.route('/panels/status', methods=['GET'])
          def get_panels_status():
              """Get status of all analyzed panels."""
              return jsonify(panel_status_cache)

          @app.route('/defects/summary', methods=['GET'])
          def get_defects_summary():
              """Get a summary of all defects."""
              defect_counts = {}
              panels_with_defects = set()
              
              # Analyze cached panel statuses
              for panel_id, status in panel_status_cache.items():
                  if status.get('status') == 'alert':
                      panels_with_defects.add(panel_id)
              
              # If using Redis, check for detailed defect information
              if redis_client:
                  for panel_id in panels_with_defects:
                      cached_analysis = redis_client.get(f"panel:{panel_id}:analysis")
                      if cached_analysis:
                          analysis = json.loads(cached_analysis)
                          for defect in analysis.get('defects', []):
                              defect_type = defect.get('identified_defect', 'unknown')
                              severity = defect.get('severity', 'unknown')
                              
                              key = f"{defect_type}:{severity}"
                              if key in defect_counts:
                                  defect_counts[key]['count'] += 1
                              else:
                                  defect_counts[key] = {
                                      'defect_type': defect_type,
                                      'severity': severity,
                                      'count': 1
                                  }
              
              summary = {
                  "total_panels_analyzed": len(panel_status_cache),
                  "panels_with_defects": len(panels_with_defects),
                  "defect_distribution": list(defect_counts.values()),
                  "timestamp": datetime.now().isoformat()
              }
              
              return jsonify(summary)
              
          @app.route('/health', methods=['GET'])
          def health_check():
              """Health check endpoint."""
              return jsonify({
                  "status": "ok",
                  "redis_connected": redis_client is not None,
                  "models_loaded": {
                      "anomaly_detector": anomaly_detector is not None,
                      "thermal_model": thermal_model is not None
                  },
                  "panels_analyzed": len(panel_status_cache),
                  "timestamp": datetime.now().isoformat()
              })

          def main():
              """Main function to start the AI processor."""
              logger.info("Starting AI Processor")
              
              # Initialize connections and models
              init()
              
              # Start background processing thread
              threading.Thread(target=background_processing, daemon=True).start()
              
              # Start the API server
              logger.info(f"Starting API server on port {API_PORT}")
              app.run(host='0.0.0.0', port=API_PORT)

          if __name__ == "__main__":
              main()
          EOF
          python /app/processor.py
        env:
        - name: REDIS_HOST
          value: "redis"
        - name: DATA_COLLECTOR_URL
          value: "http://data-collector-service:8080"
        - name: MODEL_DIR
          value: "/models"
        - name: PROCESSING_INTERVAL
          value: "300"
        - name: METRICS_PORT
          value: "9102"
        ports:
        - containerPort: 8081
        - containerPort: 9102
          name: metrics
        volumeMounts:
        - name: model-storage
          mountPath: /models
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "1"
      volumes:
      - name: model-storage
        persistentVolumeClaim:
          claimName: ml-model-storage
